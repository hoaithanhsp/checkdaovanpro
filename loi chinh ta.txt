/**
 * AI-Powered Context-Aware Spell Checker for SKKN
 * S·ª≠ d·ª•ng Gemini AI ƒë·ªÉ ph√¢n t√≠ch ng·ªØ c·∫£nh v√† s·ª≠a l·ªói ch√≠nh t·∫£ th√¥ng minh
 */

import { GoogleGenerativeAI } from '@google/generative-ai';

// ==================== CONFIGURATION ====================

const GEMINI_API_KEY = process.env.GEMINI_API_KEY || 'YOUR_API_KEY_HERE';
const genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash-exp' });

// Danh s√°ch t·ª´ vi·∫øt t·∫Øt ph·ªï bi·∫øn (whitelist c·ª©ng)
const WHITELIST_ACRONYMS = new Set([
    'KHBG', 'ƒêGTX', 'NCBH', 'HSG', 'CSDL', 'KTTX', 'THPT',
    'GDƒêT', 'UBND', 'HƒêND', 'BGD', 'S·ªû', 'PH√íNG', 'THCS', 'TP', 'VN', 'SGK',
    'GV', 'HS', 'BGH', 'CMHS', 'CNTT', 'SKKN', 'PPCT', 'KHGD', 'KHDH',
    'NQ', 'TW', 'BGDƒêT', 'ƒêSVN', 'COVID', 'WHO', 'UNESCO', 'ASEAN'
]);

// ==================== TYPES ====================

interface SKKNContext {
    title: string;           // T√™n ƒë·ªÅ t√†i SKKN
    subject: string;         // M√¥n h·ªçc (To√°n, VƒÉn, H√≥a...)
    grade: string;           // C·∫•p h·ªçc (THCS, THPT...)
    keywords: string[];      // T·ª´ kh√≥a ch√≠nh
    fullText: string;        // To√†n b·ªô n·ªôi dung (ƒë·ªÉ AI ph√¢n t√≠ch)
}

interface CorrectionDecision {
    original: string;        // T·ª´ g·ªëc
    corrected: string;       // T·ª´ ƒë√£ s·ª≠a (ho·∫∑c gi·ªØ nguy√™n)
    shouldCorrect: boolean;  // C√≥ n√™n s·ª≠a kh√¥ng?
    reason: string;          // L√Ω do (t√™n ri√™ng, thu·∫≠t ng·ªØ, l·ªói th·∫≠t...)
}

interface CorrectionCache {
    [contextHash: string]: {
        [word: string]: CorrectionDecision;
    };
}

// ==================== CACHE ====================

const correctionCache: CorrectionCache = {};

const getContextHash = (context: SKKNContext): string => {
    return `${context.subject}_${context.grade}_${context.title.substring(0, 20)}`;
};

// ==================== CONTEXT EXTRACTION ====================

/**
 * Tr√≠ch xu·∫•t ng·ªØ c·∫£nh t·ª´ to√†n b·ªô SKKN
 */
export const extractSKKNContext = (fullText: string): SKKNContext => {
    const lines = fullText.split('
').map(l => l.trim()).filter(Boolean);
    
    let title = 'Kh√¥ng x√°c ƒë·ªãnh';
    let subject = 'Chung';
    let grade = 'THCS';
    const keywords: string[] = [];

    // T√¨m t√™n ƒë·ªÅ t√†i (th∆∞·ªùng ·ªü ƒë·∫ßu ho·∫∑c c√≥ t·ª´ "T√™n ƒë·ªÅ t√†i", "ƒê·ªÅ t√†i")
    for (let i = 0; i < Math.min(10, lines.length); i++) {
        const line = lines[i];
        if (line.length > 10 && line.length < 200) {
            if (/^(T√äN ƒê·ªÄ T√ÄI|ƒê·ªÄ T√ÄI|SKKN)/i.test(line)) {
                title = lines[i + 1] || line;
                break;
            }
            if (i === 0 && line.length > 20) {
                title = line;
            }
        }
    }

    // Ph√°t hi·ªán m√¥n h·ªçc
    const subjectPatterns = [
        { pattern: /to√°n\s*h·ªçc|m√¥n\s*to√°n|gi·∫£i\s*to√°n/i, name: 'To√°n' },
        { pattern: /ng·ªØ\s*vƒÉn|vƒÉn\s*h·ªçc|m√¥n\s*vƒÉn/i, name: 'VƒÉn' },
        { pattern: /h√≥a\s*h·ªçc|m√¥n\s*h√≥a/i, name: 'H√≥a' },
        { pattern: /v·∫≠t\s*l√Ω|m√¥n\s*l√Ω/i, name: 'L√Ω' },
        { pattern: /sinh\s*h·ªçc|m√¥n\s*sinh/i, name: 'Sinh' },
        { pattern: /l·ªãch\s*s·ª≠|m√¥n\s*s·ª≠/i, name: 'S·ª≠' },
        { pattern: /ƒë·ªãa\s*l√Ω|m√¥n\s*ƒë·ªãa/i, name: 'ƒê·ªãa' },
        { pattern: /ti·∫øng\s*anh|english/i, name: 'Ti·∫øng Anh' },
        { pattern: /gi√°o\s*d·ª•c\s*c√¥ng\s*d√¢n|gdcd/i, name: 'GDCD' },
        { pattern: /tin\s*h·ªçc|c√¥ng\s*ngh·ªá\s*th√¥ng\s*tin/i, name: 'Tin h·ªçc' }
    ];

    for (const { pattern, name } of subjectPatterns) {
        if (pattern.test(fullText)) {
            subject = name;
            break;
        }
    }

    // Ph√°t hi·ªán c·∫•p h·ªçc
    if (/THPT|trung\s*h·ªçc\s*ph·ªï\s*th√¥ng|l·ªõp\s*(10|11|12)/i.test(fullText)) {
        grade = 'THPT';
    } else if (/THCS|trung\s*h·ªçc\s*c∆°\s*s·ªü|l·ªõp\s*[6-9]/i.test(fullText)) {
        grade = 'THCS';
    } else if (/ti·ªÉu\s*h·ªçc|l·ªõp\s*[1-5]/i.test(fullText)) {
        grade = 'Ti·ªÉu h·ªçc';
    }

    // Tr√≠ch xu·∫•t t·ª´ kh√≥a (c√°c t·ª´ vi·∫øt hoa xu·∫•t hi·ªán nhi·ªÅu l·∫ßn)
    const wordFreq = new Map<string, number="">();
    const words = fullText.match(/\b[A-Z√Ä-·ª∏][a-z√†-·ªπ]{2,}\b/g) || [];
    
    words.forEach(word => {
        if (word.length > 3 && !WHITELIST_ACRONYMS.has(word.toUpperCase())) {
            wordFreq.set(word, (wordFreq.get(word) || 0) + 1);
        }
    });

    // L·∫•y top 10 t·ª´ xu·∫•t hi·ªán nhi·ªÅu nh·∫•t
    const sortedWords = Array.from(wordFreq.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10)
        .map(([word]) => word);

    keywords.push(...sortedWords);

    return {
        title,
        subject,
        grade,
        keywords,
        fullText: fullText.substring(0, 3000) // Gi·ªõi h·∫°n 3000 k√Ω t·ª± cho AI
    };
};

// ==================== AI CORRECTION ====================

/**
 * G·ªçi AI ƒë·ªÉ ph√¢n t√≠ch v√† quy·∫øt ƒë·ªãnh s·ª≠a l·ªói
 */
const getAICorrectionDecisions = async (
    words: string[],
    context: SKKNContext
): Promise<correctiondecision[]> => {
    
    const prompt = `B·∫°n l√† chuy√™n gia s·ª≠a l·ªói ch√≠nh t·∫£ ti·∫øng Vi·ªát cho vƒÉn b·∫£n S√°ng ki·∫øn Kinh nghi·ªám (SKKN) gi√°o d·ª•c.

**TH√îNG TIN NG·ªÆ C·∫¢NH SKKN:**
- T√™n ƒë·ªÅ t√†i: ${context.title}
- M√¥n h·ªçc: ${context.subject}
- C·∫•p h·ªçc: ${context.grade}
- T·ª´ kh√≥a ch√≠nh: ${context.keywords.join(', ')}

**ƒêO·∫†N VƒÇN M·∫™U (ƒë·ªÉ hi·ªÉu ng·ªØ c·∫£nh):**
${context.fullText.substring(0, 500)}...

**NHI·ªÜM V·ª§:**
Ph√¢n t√≠ch danh s√°ch c√°c t·ª´ d∆∞·ªõi ƒë√¢y v√† quy·∫øt ƒë·ªãnh xem c√≥ n√™n s·ª≠a l·ªói vi·∫øt hoa hay kh√¥ng.

**C√ÅC T·ª™ C·∫¶N PH√ÇN T√çCH:**
${words.map((w, i) => `${i + 1}. "${w}"`).join('
')}

**QUY T·∫ÆC QUY·∫æT ƒê·ªäNH:**
1. **GI·ªÆ NGUY√äN** n·∫øu l√†:
   - T√™n ri√™ng c·ªßa ng∆∞·ªùi, ƒë·ªãa danh (VD: "Nguy·ªÖn VƒÉn A", "H√† N·ªôi")
   - Thu·∫≠t ng·ªØ chuy√™n ng√†nh c·ªßa m√¥n h·ªçc (VD: "Pitago", "Newton", "Mendeleev")
   - T√™n ph∆∞∆°ng ph√°p gi·∫£ng d·∫°y (VD: "Jigsaw", "Montessori")
   - T·ª´ vi·∫øt hoa h·ª£p l√Ω trong ng·ªØ c·∫£nh

2. **S·ª¨A TH√ÄNH CH·ªÆ TH∆Ø·ªúNG** n·∫øu l√†:
   - L·ªói ƒë√°nh m√°y (VD: "KH√¥ng" ‚Üí "kh√¥ng", "NH·ªØng" ‚Üí "nh·ªØng")
   - T·ª´ th∆∞·ªùng b·ªã vi·∫øt hoa nh·∫ßm (VD: "C√°c" ‚Üí "c√°c", "Nh·ªØng" ‚Üí "nh·ªØng")
   - Kh√¥ng ph·∫£i t√™n ri√™ng hay thu·∫≠t ng·ªØ

**ƒê·ªäNH D·∫†NG ƒê·∫¶U RA (JSON):**
Tr·∫£ v·ªÅ m·∫£ng JSON, m·ªói ph·∫ßn t·ª≠ c√≥ c·∫•u tr√∫c:
{
  "original": "t·ª´ g·ªëc",
  "corrected": "t·ª´ ƒë√£ s·ª≠a (ho·∫∑c gi·ªØ nguy√™n)",
  "shouldCorrect": true/false,
  "reason": "l√Ω do ng·∫Øn g·ªçn"
}

**CH·ªà TR·∫¢ V·ªÄ JSON, KH√îNG GI·∫¢I TH√çCH TH√äM.**`;

    try {
        const result = await model.generateContent(prompt);
        const responseText = result.response.text();
        
        // Parse JSON t·ª´ response
        const jsonMatch = responseText.match(/\[[\s\S]*\]/);
        if (!jsonMatch) {
            throw new Error('AI kh√¥ng tr·∫£ v·ªÅ JSON h·ª£p l·ªá');
        }

        const decisions: CorrectionDecision[] = JSON.parse(jsonMatch[0]);
        return decisions;

    } catch (error) {
        console.error('‚ùå L·ªói khi g·ªçi AI:', error);
        
        // Fallback: gi·ªØ nguy√™n t·∫•t c·∫£
        return words.map(word => ({
            original: word,
            corrected: word,
            shouldCorrect: false,
            reason: 'AI error - gi·ªØ nguy√™n an to√†n'
        }));
    }
};

// ==================== MAIN CORRECTION FUNCTION ====================

/**
 * S·ª≠a l·ªói ch√≠nh t·∫£ d·ª±a v√†o ng·ªØ c·∫£nh SKKN
 */
export const correctSpellingWithContext = async (
    text: string,
    context: SKKNContext
): Promise<string> => {
    
    if (!text.trim()) return text;

    const contextHash = getContextHash(context);
    
    // Kh·ªüi t·∫°o cache cho context n√†y n·∫øu ch∆∞a c√≥
    if (!correctionCache[contextHash]) {
        correctionCache[contextHash] = {};
    }

    const lines = text.split('
');
    const correctedLines: string[] = [];

    for (const line of lines) {
        if (!line.trim()) {
            correctedLines.push(line);
            continue;
        }

        // Gi·ªØ l·∫°i indentation
        const indentMatch = line.match(/^(\s+)/);
        const indent = indentMatch ? indentMatch[1] : '';
        const content = line.trim();

        // T√¨m t·∫•t c·∫£ c√°c t·ª´ c√≥ v·∫•n ƒë·ªÅ v·ªÅ vi·∫øt hoa
        const problematicWords: { word: string; index: number }[] = [];
        const words = content.split(/\s+/);
        
        words.forEach((word, index) => {
            const coreMatch = word.match(/[\w√Ä-·ªπ]+/);
            if (!coreMatch) return;
            
            const coreWord = coreMatch[0];
            
            // B·ªè qua whitelist
            if (WHITELIST_ACRONYMS.has(coreWord.toUpperCase())) return;
            
            // Ph√°t hi·ªán l·ªói vi·∫øt hoa
            const hasCapitalIssue = 
                /^[A-Z√Ä-·ª∏]{2,}[a-z√†-·ªπ]+$/.test(coreWord) ||  // "KH√¥ng"
                /^[A-Z√Ä-·ª∏]{2,}$/.test(coreWord) ||            // "KH√îNG"
                (/^[A-Z√Ä-·ª∏][a-z√†-·ªπ]+$/.test(coreWord) && index > 0); // "Kh√¥ng" gi·ªØa c√¢u
            
            if (hasCapitalIssue) {
                problematicWords.push({ word: coreWord, index });
            }
        });

        // N·∫øu kh√¥ng c√≥ t·ª´ n√†o c√≥ v·∫•n ƒë·ªÅ, gi·ªØ nguy√™n
        if (problematicWords.length === 0) {
            correctedLines.push(line);
            continue;
        }

        // L·ªçc c√°c t·ª´ ch∆∞a c√≥ trong cache
        const wordsToAnalyze = problematicWords
            .filter(({ word }) => !correctionCache[contextHash][word])
            .map(({ word }) => word);

        // G·ªçi AI ƒë·ªÉ ph√¢n t√≠ch (n·∫øu c√≥ t·ª´ m·ªõi)
        if (wordsToAnalyze.length > 0) {
            const decisions = await getAICorrectionDecisions(wordsToAnalyze, context);
            
            // L∆∞u v√†o cache
            decisions.forEach(decision => {
                correctionCache[contextHash][decision.original] = decision;
            });
        }

        // √Åp d·ª•ng correction
        let correctedContent = content;
        
        for (const { word } of problematicWords) {
            const decision = correctionCache[contextHash][word];
            
            if (decision && decision.shouldCorrect) {
                // Thay th·∫ø t·ª´ trong c√¢u (gi·ªØ nguy√™n d·∫•u c√¢u xung quanh)
                const regex = new RegExp(`\\b${word}\\b`, 'g');
                correctedContent = correctedContent.replace(regex, decision.corrected);
            }
        }

        correctedLines.push(indent + correctedContent);
    }

    return correctedLines.join('
');
};

// ==================== FULL PIPELINE ====================

/**
 * Pipeline ƒë·∫ßy ƒë·ªß: Extract context ‚Üí Correct spelling
 */
export const correctSKKNSpelling = async (fullText: string): Promise<string> => {
    
    console.log('üîç ƒêang ph√¢n t√≠ch ng·ªØ c·∫£nh SKKN...');
    const context = extractSKKNContext(fullText);
    
    console.log('üìä Ng·ªØ c·∫£nh ph√°t hi·ªán:', {
        title: context.title,
        subject: context.subject,
        grade: context.grade,
        keywords: context.keywords.slice(0, 5)
    });

    console.log('ü§ñ ƒêang s·ª≠a l·ªói ch√≠nh t·∫£ v·ªõi AI...');
    const correctedText = await correctSpellingWithContext(fullText, context);
    
    console.log('‚úÖ Ho√†n th√†nh!');
    return correctedText;
};

// ==================== EXPORT ====================

export default {
    extractSKKNContext,
    correctSpellingWithContext,
    correctSKKNSpelling
};
</string></string></correctiondecision[]></string,>